# 公告板
帮我测下CPU吧。

细节：
下载所有代码编译即可。
按任意一个键就可以运行下一条指令。
在CPU.Cpp->Z80::Step->#ifdef 里：
if（_REG.PC==0xabc） 更改这里可以指示开始单步执行的点，在到达这一点之前所有的指令均不会输出寄存器信息。
在MEMORY.Cpp->MemoryWrite 里：
头一句有个cout,输出的是 地址=被赋的值。不想看就注释掉。

调试功能十分简陋，没有在运行时控制是否单步调试的功能，只能从开始单步到结尾。

下载NOGMB模拟器，用它加载这个git内附的rom,记得加载时勾掉AutoStart Cartridge,这样就会从一开始就进入单步运行状态。
双击一条指令来设置断点。
F3执行到下一条（会把CALL当做一条来执行，你就当做是VS中的“逐过程”）
F4执行到光标

执行时对比右侧寄存器的值，如果有不一样的就说明有问题，看看是哪有问题，帮我改了最好。

# 十分重要的事情

由于时钟的不匹配，在执行ld a,(FF44)时A寄存器的值可能会不一样，这个先别管了。

有时候NOGMB中会有这种情况：

0001 20 3A 02     ;jp,023A

......

0239 20 21 22...  ;jp,2221

你会发现上一个jp跳转到了下一个jp指令的中间。

这时候实际执行的应该是

023A 21 22.....   ;ld 22....

老程序猿们总有些天才想法，这样复合指令可以达到节省空间的目的。但是NOGMB的调试器是对指令进行可能的最长匹配的，假如这样的话你想要设置一个断点在023A的
话，这个断点永远不会命中。一个比较懒的解决方法如下

右键下一个jp，选修改指令，直接打‘00’

这样它就能够命中断点了，但是事实上的确少了一个可能有用的jp，执行到了记得加回去-_-

每次重载ROM就需要重新改一遍(⊙o⊙)


