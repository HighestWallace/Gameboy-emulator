已经完成的部分
	CPU的指令集
	CPU可以获知并触发中断，但是并没有实装任何中断的触发方法。
	GPU的时间计算，大体上能够遵循正确的时间来进行活动,但同样没有实装任何活动。
没有完成的，但是下一步就需要完成的部分
	最简单:
	Timer 
	评价：还好，IZ大佬的代码这部分还能看懂，写了这个之后就可以出来Timer Overflow中断了。
	
	难了:
	显示。
	首先读明白显示的方法，首先由于存储器的限制，GB的显示由数据表和映射表共同生成，数据表存储着图像，详细格式及其实际位置可见手册，映射表决定背景的每个区块显示何种图案。图像的显示分为背景和窗口两个部分，同时背景，窗口，精灵三者也有关于是否可以“透明”的细节，可以在手册中找到描述。另外有多个寄存器控制它们在屏幕上的显示位置。
	我的想法是严格按照原件，一条扫描线一条扫描线的刷新（更新时机要遵循GPU时钟），最后更新一帧，这一帧的数据在内存中用数组存储，是已经按照正确顺序叠加好精灵，窗口和背景的结果，按照这个结果生成一张图片，最后渲染在GUI上。
	同时需要解决V-Blank和LCDC的问题。
	声音:
	这个暂时略过不表，我基本一点不懂
	
	游戏控制:
	这个东西涉及到Hi-to-Lo中断，不敢妄动，另外，在我看来，输入输出应由最外层的GUI接收，再传入最里层的虚拟硬件。
	
	读入ROM:
	是一个独立的过程，注意它应在的层次。

其他的东西暂且不提，目前最好先解决显示问题，这一点的另一个麻烦在于调试，因为需要看得到实际的图片。事实上现在的所有代码也未经过测试，如果有时间可以过一遍CPU指令和内存读写，看看是否有问题。
GUI的开发可能需要快些，目前的代码的可结合性应该还可以，毕竟连一个main函数都没有，Qt的安装过程有点复杂，做好心理准备。

以下是针对我所写的所有代码的解释：
CPU部分：
类名Z80
初始化的方法：声明Memory类和GPU类，作为构造函数的参数传入，将它们“组装”。
成员:
一个时间计数器CLOCK，计算在模拟器中过了多少个时间单位。
一个寄存器结构体_REG。

SetFlag，解决CPU内标志位。
相应的GetFlag。
高速缓存中标志位多样且繁杂，没有SetFlag。
isPause，isStop，主要是为了配合HALT和STOP指令，但是现在看来好像没有必要。
OpCodeList及CBOpCodeList，都是指令集。
获知中断的Interruput函数。
CPU运行一条指令的Step函数，其中做了取指，译码和执行工作，同时控制了CLOCK的增加，检查了中断。

Memory部分:

类名Memory
成员：
Read和Write

许多虚拟存储器块。

由于GB采用了映射来处理所有的存储器，参考了大佬的代码后我决定继续这一优良传统，声明了分立的数组，在MemoryWrite和MemoryRead方法中再做对应的转换。

inbios指示位

在开机时的引导程序，引导完成后会被卸载，写死在那一坨里。
MemoryWrite还没完全完成，按大佬的代码，向显存部分写入时应有个更新，但我现在没想好更新啥。

LoadRom，未实现
由于把放ROM的32Kb分为了两部分（rom_bank0 和 rom_other_bank）,在实现LoadRom时不要忘了向两处写入。

GPU部分:

类名GPU
成员：
时钟CLOCK，由CPU负责更新。
用于“组装”的Memory &，因为显存管理部分由Memory负责。
一个Screen数组,存储相应的区块编码，只有这个生成一帧是不够的，毕竟还有窗口和精灵。
line 记录已更新的扫描线数量，模拟要用
mode 记录当前屏幕的模式(有个寄存器干这事，这个变量只是用来暂存的。)

GPUStep，做GPU该干的事，显示什么的，但是没写完，就像我上面提过的
Newline和NewFrame，刷新线，刷新帧。
要不把生成图片的方法也加进去？加上一个方法，调用就返回一帧。这样底层就有机会完全封装，GUI只需发一个请求就可以得到一帧图像了，用起来会很方便。。。

我想的整个程序架构：

最内部：
CPU，存储器，GPU

中部：
对内部进行必要控制

顶部：
GUI

有许多的其他细节，不一定想的全，以后碰到了再加。

回顾一下，目前任务是先解决显示问题。

注：代码内部不要有中文，会有编码问题
关掉预编译头。
	