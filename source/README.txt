CPU貌似完成了，但是抓到了一地的BUG，开始方了。
GPU显示部分完成了大部分，但是一点都没测过，现在差把数据转为颜色的最后一步，真正显示出来不在我职责范围内，哈哈


以下是针对我所写的所有代码的解释：
CPU部分：
类名Z80
初始化的方法：声明Memory类和GPU类和timer类，作为构造函数的参数传入，将它们“组装”。
成员:

一个寄存器结构体_REG。

SetFlag，解决CPU内标志位。
相应的GetFlag。
高速缓存中标志位多样且繁杂，没有SetFlag。
isPause，isStop，除了配合指令外还可以配合生成帧的速度控制。
OpCodeList及CBOpCodeList，都是指令集。
获知中断的Interruput函数。
CPU运行一条指令的Step函数，其中做了取指，译码和执行工作，同时控制了Timer的增加，检查了中断。

Memory部分:

类名Memory
成员：
Read和Write

许多虚拟存储器块。

由于GB采用了映射来处理所有的存储器，参考了大佬的代码后我决定继续这一优良传统，声明了分立的数组，在MemoryWrite和MemoryRead方法中再做对应的转换。

inbios指示位

在开机时的引导程序，引导完成后会被卸载，写死在那一坨里。
MemoryWrite应该除了音频已经全乎了。

LoadRom，十分简陋，写死了读取地址，测的时候自己改一下。
由于把放ROM的32Kb分为了两部分（rom_bank0 和 rom_other_bank）,在实现LoadRom时不要忘了向两处写入。

GPU部分:

类名GPU
成员：
时钟CLOCK，由CPU负责更新。
用于“组装”的Memory &，因为显存管理部分由Memory负责。
一个Screen数组,存储相应的区块编码，只有这个生成一帧是不够的，毕竟还有窗口和精灵，但是这个装的是最后生成结果。
一个多用的Window数组，用作更新帧时对窗口和精灵的临时存储。
line 记录已更新的扫描线数量，模拟要用
mode 记录当前屏幕的模式(有个寄存器干这事，这个变量只是用来暂存的。)

GPUStep，做GPU该干的事，显示什么的，发送中断什么的
Newline和NewFrame，UpdateSprite，刷新线，刷新帧，刷新精灵，
NewFrame打算写成个接口，但没想好怎么往外送数据，直接复制出去？
目前的NewFrame的一个作用是整合Screen和Window，再结合三个调色板的数据（未实装），显示端需要的是读取并转化成相应颜色的像素点。

Timer部分：

并不懂，无视它吧，能用就成。

Main部分：

基本上啥也没有，只能让CPU走指令。

将来的计划
完成输入，貌似看懂了，但这个主要是GUI的工作-_-
注意输入的详细解释，不要被手册里的吃豆人的例子误导，尽量按imran的来。
CPU还需进一步测试！！！！！！！！！！！！
去死吧
GPU显示部分代码容易写乱，特别注意。
Qt。
我并不懂win32。
u：

在控制fps时不能简单粗暴的sleep，至少要分个线程！在GPU中设了一个NewFrame的标志位，显示新的一帧已经被生成，这个标志应该也可以起到统计帧生成时间的作用。。我的计划是这一标志出现后就挂起模拟器内核所在线程，但是这时候窗口要继续工作。同时监听键盘的部分最好监听到之后立刻写入内核所在线程，以防出现操作延迟，挂起一定时间后就恢复工作生成下一帧，没有彻底测试，不清楚生成一帧需要的时间，不过挂起时间是可以动态调整的。

注：代码内部不要有中文，会有编码问题
关掉预编译头。
	
